use bytemuck::{cast_slice, from_bytes};
use gltf::accessor::{DataType, Dimensions};

use crate::pipeline::Pipeline;

pub struct Importer {
    positions: Vec<f32>,
    indices: Vec<u16>,
    colors: Vec<f32>,
    uvs: Vec<f32>,
    normals: Vec<f32>,
    lighting: Vec<f32>,
}

impl Importer {
    fn has_colors(&self) -> bool {
        !self.colors.is_empty()
    }

    fn has_uvs(&self) -> bool {
        !self.uvs.is_empty()
    }

    fn has_normals(&self) -> bool {
        !self.normals.is_empty()
    }

    fn has_lighting(&self) -> bool {
        !self.lighting.is_empty()
    }

    // Some exporters might automatically export COLOR_0
    // and exporting COLOR_1
    fn clean_up_buffers(&mut self) {
        if !self.has_normals() {
            self.lighting.clear();
            // No normals = no lighting data needed at all
            return;
        }

        if self.has_lighting() {
            // We have normals and lighting, so we can operate as normal
            return;
        }

        // We aren't sure if we should use Color for lighting or vertex colors
        // Must check for an alternative color provider, in this case UVs
        if self.has_uvs() {
            // We have UVs, so we want to use COLOR for LIGHTING
            std::mem::swap(&mut self.colors, &mut self.lighting);
        } else {
            // We don't have UVs, so normals are extra unneeded data
            self.normals.clear();
        }
    }

    fn get_pipeline(&self) -> Option<Pipeline> {
        let color_pipeline = match (self.has_colors(), self.has_uvs()) {
            (true, true) => Pipeline::ColorUv,
            (true, false) => Pipeline::Color,
            (false, true) => Pipeline::Uv,
            (false, false) => return None,
        };

        if self.has_lighting() && self.has_normals() {
            Some(color_pipeline.lit())
        } else {
            Some(color_pipeline)
        }
    }

    pub fn import(mut self, target_pipeline: Pipeline) -> Vec<f32> {
        let mut out = Vec::new();

        self.clean_up_buffers();

        let import_pipeline = if let Some(pipeline) = self.get_pipeline() {
            println!("Importing pipeline: {:?}", pipeline);
            pipeline
        } else {
            println!("Invalid import.");
            return out;
        };

        let pipeline = if import_pipeline.can_reduce(target_pipeline) {
            target_pipeline
        } else {
            println!("Can't reduce {import_pipeline:?} to {target_pipeline:?}");
            return out;
        };

        let import_color = pipeline.has_color();
        let import_uv = pipeline.has_uv();
        let import_lighting = pipeline.has_lighting();

        for (index, position) in self.positions.chunks_exact(3).enumerate() {
            let start = index * 3;
            let end = start + 3;

            out.extend_from_slice(position);

            if import_color {
                out.extend_from_slice(&self.colors[start..end]);
            }

            if import_uv {
                let uv_start = index * 2;
                let uv_end = uv_start + 2;
                out.extend_from_slice(&self.uvs[uv_start..uv_end]);
            }

            if import_lighting {
                out.extend_from_slice(&self.normals[start..end]);
                out.extend_from_slice(&self.lighting[start..end]);
            }
        }
        out
    }

    /// Converts an indexed mesh into a non-indexed one
    pub fn import_indexed_to_non_indexed(mut self) -> Vec<f32> {
        let mut out = Vec::new();

        self.clean_up_buffers();

        let pipeline = if let Some(pipeline) = self.get_pipeline() {
            println!("Importing pipeline: {:?}", pipeline);
            pipeline
        } else {
            println!("Invalid import.");
            return out;
        };

        let import_color = pipeline.has_color();
        let import_uv = pipeline.has_uv();
        let import_lighting = pipeline.has_lighting();

        println!("import lighting: {import_lighting}");

        if self.indices.is_empty() {
            println!("import_indexed_to_non_index called on a mesh without indices.");
            for n in 0..self.positions.len() / 3 {
                let n = n as u16;
                self.indices.push(n)
            }
            println!("Autogenerated {} triangles.", self.indices.len() / 3);
        }

        for index in self.indices.iter().copied() {
            let start = index as usize * 3;
            let end = start + 3;

            out.extend_from_slice(&self.positions[start..end]);

            if import_color {
                out.extend_from_slice(&self.colors[start..end]);
            }

            if import_uv {
                let uv_start = index as usize * 2;
                let uv_end = uv_start + 2;
                out.extend_from_slice(&self.uvs[uv_start..uv_end]);
            }

            if import_lighting {
                out.extend_from_slice(&self.normals[start..end]);
                out.extend_from_slice(&self.lighting[start..end]);
            }
        }
        out
    }

    pub fn import_indexed(self, pipeline: Pipeline) -> (Vec<f32>, Vec<u16>) {
        if self.indices.is_empty() {
            panic!("No indices found, use import instead")
        }
        let indices = self.indices.clone();
        (self.import(pipeline), indices)
    }
}

pub fn import_gltf(path: &str) -> Importer {
    println!("Importing... {path}");
    let (document, buffers, _images) = gltf::import(path).unwrap();

    let blob = &buffers[0].0;

    let mut indices = Vec::new();
    let mut positions = Vec::new();
    let mut colors = Vec::new();
    let mut uvs = Vec::new();
    let mut normals = Vec::new();
    let mut lighting = Vec::new();

    for mesh in document.meshes() {
        let primitive = mesh.primitives().next().unwrap();
        let primitive_count = mesh.primitives().count();

        if primitive_count > 1 {
            println!(
                "Primitive count > 1 ({primitive_count}), mesh may not be exported correctly..."
            )
        }

        for (kind, attribute) in primitive.attributes() {
            if attribute.view().unwrap().buffer().index() != 0 {
                panic!("wrong buffer index");
            }
            println!(
                "Found {kind:?}: {:?} x {:?}",
                attribute.data_type(),
                attribute.dimensions()
            );
            let view = attribute.view().unwrap();
            let start = attribute.offset() + view.offset();
            let end = start + (attribute.count() * attribute.size());
            let view = &blob[start..end];

            let skip = attribute.dimensions() == Dimensions::Vec4;

            match kind {
                gltf::Semantic::Positions => {
                    let view: &[f32] = cast_slice(view);

                    for p in view {
                        positions.push(*p);
                    }
                }
                gltf::Semantic::Colors(0) => {
                    write_from_view(attribute.data_type(), skip, view, &mut colors);
                    // let view: &[f32] = cast_slice(view);

                    // for c in view {
                    //     colors.push(*c);
                    // }
                }
                gltf::Semantic::Colors(1) => {
                    write_from_view(attribute.data_type(), skip, view, &mut lighting);
                    // let view: &[f32] = cast_slice(view);

                    // for l in view {
                    //     lighting.push(*l);
                    // }
                }
                gltf::Semantic::TexCoords(_) => {
                    let view: &[f32] = cast_slice(view);

                    for t in view {
                        uvs.push(*t);
                    }
                }
                gltf::Semantic::Normals => {
                    let view: &[f32] = cast_slice(view);

                    for n in view.iter() {
                        normals.push(*n);
                    }
                }

                _ => {}
            };
        }

        if let Some(indices_accessor) = primitive.indices() {
            println!(
                "Found indices: {:?} x {:?}",
                indices_accessor.data_type(),
                indices_accessor.dimensions()
            );
            let size = indices_accessor.size();
            let start = indices_accessor.offset() + indices_accessor.view().unwrap().offset();
            let count = indices_accessor.count();
            let end = start + (count * size);

            for index in blob[start..end].chunks_exact(size) {
                let i = if size == 2 {
                    *from_bytes::<u16>(&index[0..2]) as u16
                } else if size == 4 {
                    *from_bytes::<u32>(&index[0..4]) as u16
                } else {
                    panic!("Unhandled byte size for mesh");
                };
                indices.push(i as u16);
            }
            println!("Triangles found: {}", indices.len() / 3);
        }
    }

    Importer {
        positions,
        indices,
        colors,
        uvs,
        normals,
        lighting,
    }
}

fn write_from_view(data_type: DataType, skip: bool, view: &[u8], target: &mut Vec<f32>) {
    // Determine the maximum value for normalization and the number of bytes per element
    let (max, chunks) = match data_type {
        DataType::U8 => (u8::MAX as f32, 1),
        DataType::U16 => (u16::MAX as f32, 2),
        DataType::U32 => (u32::MAX as f32, 4),
        DataType::F32 => (1.0, 4),
        _ => panic!("Unhandled data type"),
    };

    // Iterate over the data in chunks
    for (index, number) in view.chunks_exact(chunks).enumerate() {
        if skip && (index + 1) % 4 == 0 {
            continue;
        }

        let value = match data_type {
            DataType::U8 => {
                // Read a single byte and normalize
                let value = number[0] as f32;
                value / max
            }
            DataType::U16 => {
                let value: u16 = *from_bytes(number);
                value as f32 / max
            }
            DataType::U32 => {
                // Read four bytes as a u32 and normalize
                let value: u32 = *from_bytes(number);
                value as f32 / max
            }
            DataType::F32 => *from_bytes(number),
            _ => unreachable!(),
        };

        // Push the normalized value into the target vector
        target.push(value);
    }
}
