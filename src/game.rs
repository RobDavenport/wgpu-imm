use crate::{app::State, pipeline::Pipeline};
use bytemuck::{cast_slice, from_bytes};

pub struct Game {
    t: f32,

    cube: Vec<f32>,
    fox: Vec<f32>,
}

fn load_mesh(path: &str) -> Vec<f32> {
    let (document, buffers, images) = gltf::import(path).unwrap();

    let blob = &buffers[0].0;

    let mut indices = Vec::new();
    let mut positions = Vec::new();
    let mut colors = Vec::new();
    let mut uvs = Vec::new();
    let mut use_color = false;

    let mut out = Vec::new();
    let mut vertex_count: usize = 0;

    for mesh in document.meshes() {
        let primitive = mesh.primitives().next().unwrap();
        let primitive_count = mesh.primitives().count();

        if primitive_count > 1 {
            println!(
                "Primitive count > 1 ({primitive_count}), mesh may not be exported correctly..."
            )
        }

        for (kind, attribute) in primitive.attributes() {
            if attribute.view().unwrap().buffer().index() != 0 {
                panic!("wrong buffer index");
            }
            println!(
                "Found {kind:?}: {:?} x {:?}",
                attribute.data_type(),
                attribute.dimensions()
            );
            let view = attribute.view().unwrap();
            let start = attribute.offset() + view.offset();
            let end = start + (attribute.count() * attribute.size());
            let view = &blob[start..end];

            match kind {
                gltf::Semantic::Positions => {
                    let view: &[f32] = cast_slice(view);

                    for p in view {
                        positions.push(*p);
                    }
                }
                gltf::Semantic::Colors(_) => {
                    let view: &[f32] = cast_slice(view);

                    for c in view {
                        colors.push(*c);
                    }

                    use_color = true
                }
                gltf::Semantic::TexCoords(_) => {
                    let view: &[f32] = cast_slice(view);

                    for t in view {
                        uvs.push(*t);
                    }
                    use_color = false;
                }
                _ => {}
            };
        }

        if let Some(indices_accessor) = primitive.indices() {
            let size = indices_accessor.size();
            let start = indices_accessor.offset() + indices_accessor.view().unwrap().offset();
            let count = indices_accessor.count();
            let end = start + (count * size);

            for index in blob[start..end].chunks_exact(size) {
                let i = if size == 2 {
                    *from_bytes::<u16>(&index[0..2]) as u16
                } else if size == 4 {
                    *from_bytes::<u32>(&index[0..4]) as u16
                } else {
                    panic!("Unhandled byte size for mesh");
                };
                indices.push(i as u16);
            }
            println!("Triangles found: {}", indices.len() / 3);
        } else {
            indices.clear();
            for n in 0..positions.len() / 3 {
                let n = n as u16;
                indices.push(n)
            }
            println!("Autogenerated {} triangles.", indices.len() / 3);
        }

        for index in indices.iter() {
            let start = *index as usize * 3;
            let end = start + 3;
            out.extend_from_slice(&positions[start..end]);

            if use_color {
                out.extend_from_slice(&colors[start..end])
            } else {
                out.extend_from_slice(&uvs[*index as usize * 2..*index as usize * 2 + 2]);
            }
        }
    }

    out
}

impl Game {
    pub fn new() -> Self {
        let cube = load_mesh("assets/BoxVertexColors.glb");
        let fox = load_mesh("assets/Fox.glb");

        Self { t: 0.0, cube, fox }
    }

    pub fn update(&mut self) {
        self.t += 1.0 / 60.0;
    }

    pub fn draw(&self, state: &mut State) {
        // let sin = self.t.sin();
        // let cos = self.t.cos();
        // let data = [
        //     // X Y Z, R G B
        //     1.0,
        //     1.0,
        //     0.0,
        //     1.0 + sin * 0.1,
        //     0.0 + cos * 0.2,
        //     0.0 + sin * 0.5, // V1
        //     -1.0,
        //     1.0,
        //     0.0,
        //     0.0 + cos * 0.3,
        //     1.0 + sin * 0.25,
        //     0.0 + cos * 0.2, // V2
        //     -1.0,
        //     -1.0,
        //     0.0,
        //     0.0 + sin * 0.2,
        //     0.0 + cos * 0.1,
        //     1.0 + sin * 0.3, // V3
        // ];
        state.draw_tri_list(&self.cube, Pipeline::Color);
        state.draw_tri_list(&self.fox, Pipeline::Uv);
    }
}
