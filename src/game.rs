use crate::{app::State, light, pipeline::Pipeline};
use bytemuck::{cast_slice, from_bytes};
use glam::{Mat4, Vec3};

pub struct Game {
    t: f32,
    tex_index: usize,

    cube: Vec<f32>,
    fox: Vec<f32>,
}

fn load_mesh(path: &str) -> Vec<f32> {
    let (document, buffers, images) = gltf::import(path).unwrap();

    let blob = &buffers[0].0;

    let mut indices = Vec::new();
    let mut positions = Vec::new();
    let mut colors = Vec::new();
    let mut uvs = Vec::new();
    let mut normals = Vec::new();
    let mut lighting = Vec::new();

    let mut out = Vec::new();

    for mesh in document.meshes() {
        let primitive = mesh.primitives().next().unwrap();
        let primitive_count = mesh.primitives().count();

        if primitive_count > 1 {
            println!(
                "Primitive count > 1 ({primitive_count}), mesh may not be exported correctly..."
            )
        }

        for (kind, attribute) in primitive.attributes() {
            if attribute.view().unwrap().buffer().index() != 0 {
                panic!("wrong buffer index");
            }
            println!(
                "Found {kind:?}: {:?} x {:?}",
                attribute.data_type(),
                attribute.dimensions()
            );
            let view = attribute.view().unwrap();
            let start = attribute.offset() + view.offset();
            let end = start + (attribute.count() * attribute.size());
            let view = &blob[start..end];

            match kind {
                gltf::Semantic::Positions => {
                    let view: &[f32] = cast_slice(view);

                    for p in view {
                        positions.push(*p);
                    }
                }
                gltf::Semantic::Colors(0) => {
                    let view: &[f32] = cast_slice(view);

                    for c in view {
                        colors.push(*c);
                    }
                }
                gltf::Semantic::Colors(1) => {
                    let view: &[f32] = cast_slice(view);

                    for l in view {
                        lighting.push(*l);
                    }
                }
                gltf::Semantic::TexCoords(_) => {
                    let view: &[f32] = cast_slice(view);

                    for t in view {
                        uvs.push(*t);
                    }
                }
                gltf::Semantic::Normals => {
                    let view: &[f32] = cast_slice(view);

                    for n in view {
                        normals.push(*n);
                    }
                }

                _ => {}
            };
        }

        if let Some(indices_accessor) = primitive.indices() {
            let size = indices_accessor.size();
            let start = indices_accessor.offset() + indices_accessor.view().unwrap().offset();
            let count = indices_accessor.count();
            let end = start + (count * size);

            for index in blob[start..end].chunks_exact(size) {
                let i = if size == 2 {
                    *from_bytes::<u16>(&index[0..2]) as u16
                } else if size == 4 {
                    *from_bytes::<u32>(&index[0..4]) as u16
                } else {
                    panic!("Unhandled byte size for mesh");
                };
                indices.push(i as u16);
            }
            println!("Triangles found: {}", indices.len() / 3);
        } else {
            indices.clear();
            for n in 0..positions.len() / 3 {
                let n = n as u16;
                indices.push(n)
            }
            println!("Autogenerated {} triangles.", indices.len() / 3);
        }

        let has_colors = !colors.is_empty();
        let has_normals = !normals.is_empty();
        let has_lighting = !lighting.is_empty();
        let has_uvs = !uvs.is_empty();

        // We have normals and colors, but not explicit lighting...
        if has_normals && has_uvs && !has_lighting && has_colors {
            println!("Using COLOR_0 for Lighting");
            std::mem::swap(&mut colors, &mut lighting);
        }

        for index in indices.iter() {
            let start = *index as usize * 3;
            let end = start + 3;
            out.extend_from_slice(&positions[start..end]);

            if !colors.is_empty() {
                out.extend_from_slice(&colors[start..end])
            }

            if !uvs.is_empty() {
                out.extend_from_slice(&uvs[*index as usize * 2..*index as usize * 2 + 2]);
            }

            if !normals.is_empty() && !lighting.is_empty() {
                out.extend_from_slice(&normals[start..end]);
                out.extend_from_slice(&lighting[start..end]);
            }
        }
    }

    out
}

impl Game {
    pub fn new() -> Self {
        let cube = load_mesh("assets/BoxVertexColors.glb");
        let fox = load_mesh("assets/Fox.glb");

        Self {
            t: 0.0,
            cube,
            fox,
            tex_index: 0,
        }
    }

    pub fn init(&mut self, state: &mut State) {
        self.tex_index = state.load_texture("assets/Fox.png");
    }

    pub fn update(&mut self) {
        self.t += 1.0 / 60.0;
    }

    pub fn draw(&self, state: &mut State) {
        state.push_matrix(Mat4::IDENTITY);
        state.draw_tri_list(&self.cube, Pipeline::Color);
        state.set_texture(self.tex_index);
        state.push_matrix(Mat4::from_scale(Vec3::splat(0.025)));
        state.draw_tri_list(&self.fox, Pipeline::Uv);
        state.push_matrix(Mat4::from_translation(Vec3::new(-2.0, 0.0, 0.0)));
        state.draw_tri_list(&self.cube, Pipeline::Color);
        state.push_matrix(Mat4::from_translation(Vec3::new(2.0, 0.0, 0.0)));
        state.draw_tri_list(&self.cube, Pipeline::Color);
    }
}
