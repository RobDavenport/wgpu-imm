use crate::app::State;
use bytemuck::{cast_slice, from_bytes};
use gltf::Gltf;

pub struct Game {
    t: f32,

    cube: Vec<f32>,
}

impl Game {
    pub fn new() -> Self {
        let (document, buffers, images) = gltf::import("assets/BoxVertexColors.glb").unwrap();

        let blob = &buffers[0].0;

        let mut indices = Vec::new();
        let mut positions = Vec::new();
        let mut colors = Vec::new();

        let mut cube = Vec::new();
        let mut vertex_count: usize = 0;

        for mesh in document.meshes() {
            let primitive = mesh.primitives().next().unwrap();
            let primitive_count = mesh.primitives().count();

            if primitive_count > 1 {
                println!(
                    "Primitive count > 1 ({primitive_count}), mesh may not be exported correctly..."
                )
            }

            for (kind, attribute) in primitive.attributes() {
                if attribute.view().unwrap().buffer().index() != 0 {
                    panic!("wrong buffer index");
                }
                println!(
                    "Found {kind:?}: {:?} x {:?}",
                    attribute.data_type(),
                    attribute.dimensions()
                );
                let view = attribute.view().unwrap();
                let start = attribute.offset() + view.offset();
                let end = start + (attribute.count() * attribute.size());
                let view = &blob[start..end];

                match kind {
                    gltf::Semantic::Positions => {
                        let view: &[f32] = cast_slice(view);

                        for p in view {
                            positions.push(*p);
                        }
                    }
                    gltf::Semantic::Colors(_) => {
                        let view: &[f32] = cast_slice(view);

                        for c in view {
                            colors.push(*c);
                        }
                    }
                    _ => {}
                };
            }

            if let Some(indices_accessor) = primitive.indices() {
                let size = indices_accessor.size();
                let start = indices_accessor.offset() + indices_accessor.view().unwrap().offset();
                let count = indices_accessor.count();
                let end = start + (count * size);

                for index in blob[start..end].chunks_exact(size) {
                    let i = if size == 2 {
                        *from_bytes::<u16>(&index[0..2]) as u16
                    } else if size == 4 {
                        *from_bytes::<u32>(&index[0..4]) as u16
                    } else {
                        panic!("Unhandled byte size for mesh");
                    };
                    indices.push(i as u16);
                }
                println!("Triangles found: {}", indices.len() / 3);
            } else {
                indices.clear();
                for n in 0..positions.len() {
                    let n = n as u16;
                    indices.push(n)
                }
                println!("Autogenerated {} triangles.", indices.len());
            }

            for index in indices.iter() {
                let start = *index as usize * 3;
                let end = start + 3;
                cube.extend_from_slice(&positions[start..end]);
                cube.extend_from_slice(&colors[start..end])
            }
        }

        Self { t: 0.0, cube }
    }

    pub fn update(&mut self) {
        self.t += 1.0 / 60.0;
    }

    pub fn draw(&self, state: &mut State) {
        // let sin = self.t.sin();
        // let cos = self.t.cos();
        // let data = [
        //     // X Y Z, R G B
        //     1.0,
        //     1.0,
        //     0.0,
        //     1.0 + sin * 0.1,
        //     0.0 + cos * 0.2,
        //     0.0 + sin * 0.5, // V1
        //     -1.0,
        //     1.0,
        //     0.0,
        //     0.0 + cos * 0.3,
        //     1.0 + sin * 0.25,
        //     0.0 + cos * 0.2, // V2
        //     -1.0,
        //     -1.0,
        //     0.0,
        //     0.0 + sin * 0.2,
        //     0.0 + cos * 0.1,
        //     1.0 + sin * 0.3, // V3
        // ];
        state.draw_tri_list(&self.cube);
    }
}
